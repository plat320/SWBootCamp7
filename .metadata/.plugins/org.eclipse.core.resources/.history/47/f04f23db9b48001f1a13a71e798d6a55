#include "snake.h"
#include "device_driver.h"
#include <stdlib.h>



// Image
unsigned short apple_img[400] = {
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x10A0, 0x10A0,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x29A2, 0x63C6, 0x9D87, 0x1080, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x2081, 0x5142, 0x0000, 0x5BE5, 0xA6C9, 0xBF8A, 0x4B04, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x48E2, 0x4223, 0x6628, 0x65C7, 0x2AE3, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x2041, 0x79A7, 0xA1E8, 0x9166, 0x58C3, 0x2021, 0x4A83, 0x5BA5, 0x79E4, 0x68A4, 0x4082, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3882, 0xF38F, 0xFCB3, 0xFBAF, 0xFAEC, 0xFA6A, 0xE1C8, 0xC986, 0xE147,
0xF988, 0xF9C9, 0xF167, 0xA8E5, 0x1020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0800, 0xDA8B, 0xFC72, 0xF36E, 0xF2AB, 0xF2AB,
0xF26B, 0xF22A, 0xF1E9, 0xF1C8, 0xE9A8, 0xE167, 0xD926, 0xE926, 0x98A4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x40A2, 0xFB6E,
0xF36E, 0xF26A, 0xF229, 0xF209, 0xF1E9, 0xF1E9, 0xE9C8, 0xE9A8, 0xE987, 0xE947, 0xD905, 0xD0E5, 0xD0A4, 0x2020, 0x0000, 0x0000,
0x0000, 0x0000, 0x7125, 0xFB6E, 0xF2EC, 0xF22A, 0xF209, 0xF1E9, 0xF1C9, 0xF1A8, 0xE988, 0xE967, 0xE967, 0xE947, 0xD8E5, 0xC8A4,
0xC883, 0x4821, 0x0000, 0x0000, 0x0000, 0x0000, 0x8966, 0xFB2D, 0xF28B, 0xF209, 0xF1E9, 0xF1C8, 0xF1A8, 0xE988, 0xE967, 0xE947,
0xE926, 0xE926, 0xD8E5, 0xC083, 0xC863, 0x4821, 0x0000, 0x0000, 0x0000, 0x0000, 0x8125, 0xFACC, 0xF24A, 0xF1E9, 0xF1C8, 0xE9A8,
0xE988, 0xE967, 0xE947, 0xE926, 0xE906, 0xE8E6, 0xE0C5, 0xB862, 0xC042, 0x3800, 0x0000, 0x0000, 0x0000, 0x0000, 0x50A3, 0xFA4A,
0xEA09, 0xF1C8, 0xF1A8, 0xE988, 0xE967, 0xE947, 0xE927, 0xE906, 0xE8E6, 0xE0C5, 0xC883, 0xB842, 0xA821, 0x1000, 0x0000, 0x0000,
0x0000, 0x0000, 0x1020, 0xE1C8, 0xF1C8, 0xE9A8, 0xE167, 0xE146, 0xE126, 0xE106, 0xE0E5, 0xD8C5, 0xD0A4, 0xC863, 0xB842, 0xB821,
0x8021, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x80E4, 0xF9A8, 0xD946, 0xD926, 0xD905, 0xD0E5, 0xD0C4, 0xC8A4, 0xC883,
0xC063, 0xC042, 0xB021, 0xB021, 0x3800, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0800, 0xC926, 0xE126, 0xD105, 0xD0E5,
0xD0C4, 0xC8A4, 0xC883, 0xC063, 0xC042, 0xB022, 0xB001, 0x8801, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x4061, 0xE906, 0xD0E5, 0xC8C4, 0xC8A4, 0xD083, 0xC863, 0xC042, 0xB021, 0xA801, 0xA801, 0x2000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x7082, 0xD0C4, 0xD0A4, 0xC883, 0xA042, 0x9842, 0xB021, 0xB001, 0xA001, 0x3000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2020, 0x3821, 0x2000, 0x0000, 0x0000, 0x2800,
0x4000, 0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};
unsigned short grass_img[400] = {
0x84E5, 0x84A6, 0x9545, 0x8D05, 0x8D25, 0x8504, 0x84C5, 0x84E5, 0x8CE5, 0x84C6, 0x84E5, 0x8505, 0x84E5, 0x84E5, 0x8504, 0x8505,
0x8D45, 0x7D04, 0x7CC4, 0x8525, 0x84E5, 0x84E5, 0x8D25, 0x84E4, 0x84E5, 0x84E5, 0x8D05, 0x84E5, 0x7CE5, 0x7CE5, 0x8505, 0x8526,
0x7CE6, 0x7CC5, 0x84E5, 0x84E5, 0x8505, 0x8545, 0x8505, 0x7CE4, 0x84E5, 0x8524, 0x8504, 0x84A5, 0x84A5, 0x84E5, 0x8D25, 0x8505,
0x7CC5, 0x7CE5, 0x84E5, 0x7CC5, 0x74C5, 0x74A5, 0x7D05, 0x8505, 0x7CE5, 0x8506, 0x8D25, 0x8D05, 0x7CC5, 0x7CE4, 0x8505, 0x84C5,
0x84E5, 0x8505, 0x8505, 0x8505, 0x7CC5, 0x7CC6, 0x8506, 0x8506, 0x8506, 0x7D05, 0x7CE5, 0x7CE5, 0x8525, 0x8505, 0x8D05, 0x84E5,
0x7CE5, 0x7CE4, 0x84C5, 0x7CC4, 0x7D05, 0x7CE4, 0x7CC5, 0x8D25, 0x7D05, 0x7CC6, 0x7CE5, 0x8526, 0x8D66, 0x7CE5, 0x8505, 0x8525,
0x8505, 0x7CE4, 0x7CC5, 0x7CC5, 0x8D05, 0x8D05, 0x8525, 0x84E4, 0x84E5, 0x7CE5, 0x74A4, 0x7CC5, 0x8525, 0x8525, 0x7D05, 0x7CC5,
0x8D06, 0x8505, 0x8545, 0x7D24, 0x7CE5, 0x7CE5, 0x8505, 0x7CC5, 0x8505, 0x84E5, 0x7484, 0x9546, 0x84E4, 0x8505, 0x7CE5, 0x8D25,
0x8544, 0x7D04, 0x8525, 0x8525, 0x84E5, 0x8525, 0x8545, 0x7D44, 0x74C5, 0x8505, 0x7CE4, 0x84E5, 0x84E5, 0x84E5, 0x7CC6, 0x8D05,
0x8505, 0x8D45, 0x8525, 0x8505, 0x8524, 0x7D24, 0x8D45, 0x8D25, 0x8525, 0x8D45, 0x84E5, 0x8505, 0x7CE5, 0x7CE5, 0x7CE4, 0x7CE4,
0x84E4, 0x7CC4, 0x7CC5, 0x8D05, 0x8D05, 0x84E4, 0x8525, 0x7CE4, 0x7CC4, 0x8525, 0x8525, 0x8D45, 0x7D24, 0x8D45, 0x84E5, 0x8D26,
0x8525, 0x8526, 0x84E5, 0x7CA5, 0x84E5, 0x8504, 0x7CC5, 0x7CE5, 0x8D65, 0x7D04, 0x8525, 0x8D45, 0x7CC5, 0x7D05, 0x8504, 0x8D25,
0x84E5, 0x8505, 0x9565, 0x8505, 0x8D25, 0x8D45, 0x8D05, 0x84C5, 0x84E5, 0x8504, 0x84E4, 0x84E5, 0x8504, 0x8505, 0x8D45, 0x7D04,
0x7CC4, 0x8505, 0x84E5, 0x84C6, 0x9545, 0x8D05, 0x8D25, 0x8524, 0x84C5, 0x8504, 0x8D05, 0x84E6, 0x84E5, 0x84E4, 0x7CE4, 0x7CA5,
0x84C5, 0x8D05, 0x8505, 0x8D45, 0x8505, 0x7CE4, 0x84E5, 0x84E5, 0x8D25, 0x8504, 0x8505, 0x8505, 0x8D05, 0x84C5, 0x84E4, 0x84E5,
0x7CE5, 0x7CC5, 0x8525, 0x7CA4, 0x7CE5, 0x8525, 0x8505, 0x8505, 0x8D25, 0x8D05, 0x84E5, 0x8524, 0x8504, 0x7CE5, 0x8D25, 0x84E5,
0x7CC5, 0x84E5, 0x7CC5, 0x84E5, 0x8506, 0x7CE5, 0x7CA4, 0x7D04, 0x8505, 0x84E5, 0x84E5, 0x8D26, 0x8D25, 0x8505, 0x7CC5, 0x84E4,
0x8525, 0x7CC4, 0x8505, 0x8525, 0x8505, 0x84E5, 0x7CE5, 0x84E6, 0x7CE5, 0x84E5, 0x7CE4, 0x7CA5, 0x7CC5, 0x74A4, 0x7CE4, 0x8504,
0x7CC5, 0x7CC5, 0x7CE5, 0x7CE4, 0x8505, 0x7D04, 0x8505, 0x8D25, 0x8525, 0x7D05, 0x7D05, 0x7CC6, 0x7D05, 0x7CC5, 0x74A4, 0x74A4,
0x74C4, 0x74A4, 0x7CE4, 0x8505, 0x7CC4, 0x7CC5, 0x8D06, 0x8505, 0x84E5, 0x8D24, 0x8D25, 0x84E5, 0x8505, 0x7CC5, 0x8525, 0x8545,
0x8525, 0x8525, 0x8505, 0x74C4, 0x7483, 0x7CC4, 0x7CE4, 0x7CE5, 0x74A5, 0x84E5, 0x8525, 0x84E5, 0x84E5, 0x8D25, 0x8524, 0x7CC4,
0x7CC5, 0x7CE5, 0x8524, 0x7D04, 0x8D45, 0x8525, 0x8525, 0x8505, 0x7CE4, 0x7CC4, 0x8504, 0x7CC4, 0x7CC5, 0x7CC5, 0x8505, 0x8504,
0x7CC4, 0x7CE4, 0x8505, 0x7CC5, 0x7CC5, 0x7CC5, 0x7D05, 0x7D24, 0x8525, 0x8D45, 0x7D24, 0x8524, 0x8505, 0x84E5, 0x7CC4, 0x8505,
0x84C5, 0x7CA5, 0x8504, 0x7CE4, 0x7CE4, 0x84E4, 0x8505, 0x8505, 0x8D46, 0x7CE4, 0x7CC5, 0x8525, 0x8504, 0x8D25, 0x84E5, 0x84E5,
0x9565, 0x8505, 0x8D25, 0x8D45, 0x84E5, 0x7CA5, 0x84E4, 0x84E4, 0x74A4, 0x7CC4, 0x8D45, 0x7D04, 0x8525, 0x8D45, 0x7CC4, 0x8505
};

unsigned short snake_head_img [400] = {
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0881, 0x08A1, 0x0020, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1962, 0x4305, 0x4BA7, 0x5407, 0x64A8, 0x5C48,
0x4B86, 0x1962, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2A03, 0x64A9, 0x5C88,
0x5C68, 0x5C48, 0x64C9, 0x6D09, 0x6D29, 0x6D49, 0x3244, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0881, 0x5448, 0x5428, 0x5C28, 0x5C28, 0x5C48, 0x64C9, 0x64E9, 0x64C9, 0x64C9, 0x64E9, 0x08C1, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0020, 0x8406, 0xA589, 0x5C48, 0x5428, 0x5C48, 0x5C48, 0x64C9, 0x64E9, 0x64C9, 0x6CC9, 0xBE4A, 0x9CE7,
0x0020, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3182, 0xDE67, 0xDE26, 0xA549, 0x5428, 0x5C48, 0x5C48, 0x64C9, 0x64E9,
0x5CC9, 0xB60A, 0xFF27, 0xFF67, 0x41E2, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4202, 0x52A3, 0x41E2, 0xD648, 0x5C28,
0x5C48, 0x5C48, 0x64C9, 0x64E9, 0x64C9, 0xEF49, 0x5263, 0x5AC3, 0x5282, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1080,
0x83E4, 0xACC4, 0xC5E8, 0x5428, 0x5C48, 0x5C48, 0x64C9, 0x64E9, 0x64C9, 0xDEC9, 0xB564, 0x9C84, 0x18A0, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x31E2, 0xADE8, 0x6C68, 0x5428, 0x5C48, 0x5C48, 0x64C9, 0x64E9, 0x64C9, 0x7D29, 0xBEA8, 0x4222,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x43C7, 0x5C48, 0x5C48, 0x5C48, 0x5C48, 0x64C9, 0x64E9,
0x64C9, 0x6509, 0x4BE8, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x3AE5, 0x5C68, 0x5428,
0x5C48, 0x5428, 0x5CA9, 0x64C9, 0x64C9, 0x6D29, 0x3AA5, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x1921, 0x7528, 0x5C48, 0x5428, 0x6CC8, 0x85C8, 0x6D09, 0x6D09, 0x7DA9, 0x10E1, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x63E4, 0x9E68, 0x8DA7, 0x9E27, 0xB708, 0xAEC8, 0xB768, 0x7485, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0840, 0x8526, 0xA687, 0x95C7, 0xA687, 0xB748,
0xA687, 0x10A0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0880,
0x7CC5, 0x95E6, 0x9E67, 0xAEC7, 0x29C2, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x5344, 0x9526, 0x2141, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0800, 0x2821, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1841, 0x3082, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x2861, 0x48C3, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};



void Snake_Init(void)
{
	int i, j;
	for (i = 0; i < GAME_OBJECT_MAP_ROW; i++)
	{
		for (j = 0; j < GAME_OBJECT_MAP_COLUMN; j++)
		{
			snake_object.object_map[i][j] = EMPTY_ID;
		}
	}
	snake_object.snake_head_dir = KEY_RIGHT;

	Uart_Printf("1\n");
	snake_object.queue_no = OS_Create_Queue(sizeof(POINT), 10);
//	Uart_Printf("*** snake_object.queue_no: %d\n", snake_object.queue_no);
	POINT p1 = {4,5};
	POINT p2 = {5,5};
	POINT p3 = {6,5};
	POINT p4 = {-1,-1};
	Uart_Printf("2\n");
	snake_object.snake_head_pos = *((POINT*)queues[snake_object.queue_no].rear->data);
	snake_object.snake_tail_pos = p4;

	snake_object.object_map[p1.x][p1.y] = SNAKE_ID;
	snake_object.object_map[p2.x][p2.y] = SNAKE_ID;
	snake_object.object_map[p3.x][p3.y] = SNAKE_ID;

	enqueue(&queues[snake_object.queue_no], &p1);
	enqueue(&queues[snake_object.queue_no], &p2);
	enqueue(&queues[snake_object.queue_no], &p3);
	draw_init();
	Lcd_Draw_Snake();
	Make_Target();
}

void draw_init(){
	Lcd_Draw_Border();
	Lcd_Draw_Grass();
}

void Lcd_Draw_Grass(){
	int i, j;
    for ( i = 1; i < GAME_WINDOW_HIGHT / OBJECT_BLOCK_SIZE -1; i++) {
        for (j = 1; j < GAME_WINDOW_WIDTH / OBJECT_BLOCK_SIZE -1; j++) {
            Lcd_Draw_IMG(j*OBJECT_BLOCK_SIZE, i*OBJECT_BLOCK_SIZE,  20,  20,  &grass_img);
        }
    }
}

void Lcd_Draw_Border(void){
	int i;
	for (i = 0; i < GAME_WINDOW_ROW; i++)
	{
		Lcd_Draw_Box(i * OBJECT_BLOCK_SIZE, 0, OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, BORDER_COLOR);
		Lcd_Draw_Box(0, i * OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, BORDER_COLOR);
		Lcd_Draw_Box(i * OBJECT_BLOCK_SIZE, (GAME_WINDOW_ROW - 1) * OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, BORDER_COLOR);
		Lcd_Draw_Box((GAME_WINDOW_ROW - 1) * OBJECT_BLOCK_SIZE, i * OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, BORDER_COLOR);
	}
}

void Lcd_Draw_Snake(void){
	Node* node = queues[snake_object.queue_no].front;
	int head_dir = snake_object.snake_head_dir;
	int tail_pos_x = snake_object.snake_tail_pos.x;
	int tail_pos_y = snake_object.snake_tail_pos.y;

	unsigned short rotated_head_img[400];

	// draw curr head  => 뱀머리
	POINT* p = (POINT*)node->data;

	rotate_image_array(snake_head_img, rotated_head_img, head_dir);
	Lcd_Draw_IMG(p->x*OBJECT_BLOCK_SIZE, p->y*OBJECT_BLOCK_SIZE,  OBJECT_BLOCK_SIZE,  OBJECT_BLOCK_SIZE,  &rotated_head_img);

	// draw prev head
	node = node->next;
	p = (POINT*)node->data;

	Lcd_Draw_Box(p->x*OBJECT_BLOCK_SIZE, p->y*OBJECT_BLOCK_SIZE,  OBJECT_BLOCK_SIZE,  OBJECT_BLOCK_SIZE,  SNAKE_COLOR);

	// draw tail
	if (tail_pos_x != -1 && tail_pos_y != -1) {
		Lcd_Draw_IMG(tail_pos_x*OBJECT_BLOCK_SIZE, tail_pos_y*OBJECT_BLOCK_SIZE,  OBJECT_BLOCK_SIZE,  OBJECT_BLOCK_SIZE,  grass_img);
	}

}

void rotate_image_array(unsigned short* image_array, unsigned short *temp, int direction) {
    int i, j;

    // direction 값에 따라 회전 방향을 결정
    switch (direction) {
        case 2: // direction = 0일 때 (원래 방향, 위쪽)
            for (i = 0; i < OBJECT_BLOCK_SIZE; i++) {
                for (j = 0; j < OBJECT_BLOCK_SIZE; j++) {
                    temp[i*OBJECT_BLOCK_SIZE+j] = image_array[i*OBJECT_BLOCK_SIZE+j];
                }
            }
            break;
        case 3: // direction = 1일 때 (시계 방향으로 90도 회전, 왼쪽)
            for (i = 0; i < OBJECT_BLOCK_SIZE; i++) {
                for (j = 0; j < OBJECT_BLOCK_SIZE; j++) {
                    temp[OBJECT_BLOCK_SIZE*j+OBJECT_BLOCK_SIZE - 1 - i] = image_array[OBJECT_BLOCK_SIZE*i+OBJECT_BLOCK_SIZE+j];
                }
            }
            break;
        case 1: // direction = 2일 때 (180도 회전, 아래쪽)
            for (i = 0; i < OBJECT_BLOCK_SIZE; i++) {
                for (j = 0; j < OBJECT_BLOCK_SIZE; j++) {
                    temp[(OBJECT_BLOCK_SIZE - 1 - i)*OBJECT_BLOCK_SIZE + OBJECT_BLOCK_SIZE - 1 - j] = image_array[i*OBJECT_BLOCK_SIZE+j];
                }
            }
            break;
        case 4: // direction = 3일 때 (반시계 방향으로 90도 회전, 왼쪽)
            for (i = 0; i < OBJECT_BLOCK_SIZE; i++) {
                for (j = 0; j < OBJECT_BLOCK_SIZE; j++) {
                    temp[(OBJECT_BLOCK_SIZE - 1 - j)*OBJECT_BLOCK_SIZE+i] = image_array[i*OBJECT_BLOCK_SIZE+j];
                }
            }
            break;
        default: // 그 외의 경우
//            printf("잘못된 방향입니다.\n");
            return;
    }

    return;

//    // 회전된 이미지를 원본 이미지 배열에 복사
//    for (i = 0; i < OBJECT_BLOCK_SIZE; i++) {
//        for (j = 0; j < OBJECT_BLOCK_SIZE; j++) {
//        	image_array[i*OBJECT_BLOCK_SIZE+j] = temp[i*OBJECT_BLOCK_SIZE+j];
//        }
//    }
}



void Add_Snake_Position(POINT* p)
{
	enqueue(&queues[snake_object.queue_no], p);
	snake_object.object_map[p->x][p->y] = SNAKE_ID;
//	Lcd_Draw_Box(p->x * OBJECT_BLOCK_SIZE, p->y * OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, SNAKE_COLOR);
}

void Remove_Snake_Position(void)
{
	POINT p;
	int ret = dequeue(&queues[snake_object.queue_no], &p, HAVE_PERMISSION);
	if (ret != DEQUEUE_SUCCESS)
	{
		Uart_Printf("Dequeue fail!\n");
	}
	snake_object.object_map[p.x][p.y] = EMPTY_ID;
//	Lcd_Draw_Box(p.x * OBJECT_BLOCK_SIZE, p.y * OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, BACKGROUND_COLOR);
}
void Move_Snake_Position(int received_head_dir)
{
//	Uart_Printf("Move_Snake_Position Start\n");
	POINT* head_position = (POINT*)queues[snake_object.queue_no].rear->data;
	POINT new_head_position = {head_position -> x, head_position -> y};
//	POINT tail_position;

	// 기존 뱀 진행 방향의 반대 방향이 입력으로 들어오면 무시하고 그렇지 않은 경우에만 입력값으로 방향 업데이트
	if (received_head_dir * snake_object.snake_head_dir != KEY_UP * KEY_DOWN
			&& received_head_dir * snake_object.snake_head_dir != KEY_LEFT * KEY_RIGHT)
	{
		snake_object.snake_head_dir = received_head_dir;
	}

	if (snake_object.snake_head_dir == KEY_UP)
	{
		new_head_position.y -= 1;
	}
	else if (snake_object.snake_head_dir == KEY_DOWN)
	{
		new_head_position.y += 1;
	}
	else if (snake_object.snake_head_dir == KEY_LEFT)
	{
		new_head_position.x -= 1;
	}
	else if (snake_object.snake_head_dir == KEY_RIGHT)
	{
		new_head_position.x += 1;
	}
//	Uart_Printf("before enqueue\n");
//	enqueue(&queues[snake_object.queue_no], &new_head_position);
//	Uart_Printf("after enqueue\n");
//	int ret = dequeue(&queues[snake_object.queue_no], &tail_position, HAVE_PERMISSION);
//	Uart_Printf("ret: %d\n", ret);
//	Uart_Printf("after dequeue\n");

	int ret = Check_Snake_Position(new_head_position);

	if (ret == TARGET_ID)
	{
		POINT p = {-1,-1};
		snake_object.snake_head_pos = new_head_position;
		snake_object.snake_tail_pos = p;

		Add_Snake_Position(&new_head_position);
//		Remove_Snake_Position();
	}
	else if (ret == EMPTY_ID)
	{
		snake_object.snake_head_pos = new_head_position;
		snake_object.snake_tail_pos = *((POINT*)queues[snake_object.queue_no].front->data);

		Add_Snake_Position(&new_head_position);
		Remove_Snake_Position();
	}

//	snake_object.snake_head_pos = new_head_position;
//	snake_object.snake_tail_pos = *((POINT*)queues[snake_object.queue_no].front->data);
//
//	Add_Snake_Position(&new_head_position);
//	Remove_Snake_Position();

//	Lcd_Draw_New_Position(&new_head_position, &tail_position);
//	Uart_Printf("Move_Snake_Position End\n");
}

int Check_Snake_Position(POINT p)
{
	switch (snake_object.object_map[p.x][p.y])
	{
		case SNAKE_ID:
			// TODO: Game over
			return SNAKE_ID;
		case TARGET_ID:
			snake_object.score += 1;
			Uart_Printf("score: %d\n", snake_object.score);
			Make_Target();
			return TARGET_ID;
		default:
			return EMPTY_ID;
	}
}



//void Lcd_Draw_New_Position(POINT* head_position, POINT* tail_position)
//{
////	Uart_Printf("Lcd_Draw_New_Position Start\n");
//	Lcd_Draw_Box(head_position->x * OBJECT_BLOCK_SIZE, head_position->y * OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, SNAKE_COLOR);
//	Lcd_Draw_Box(tail_position->x * OBJECT_BLOCK_SIZE, tail_position->y * OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, BACKGROUND_COLOR);
////	Uart_Printf("Lcd_Draw_New_Position End\n");
//}

void Calculate_Snake_Position(int head_direction)
{
	// TODO: 가고 있는 방향 반대 방향으로 전환하면 무시
//	Uart_Printf("Calculate_Snake_Position Start\n");
	POINT* head_position = (POINT*)queues[snake_object.queue_no].rear->data;
	POINT new_head_position = {head_position -> x, head_position -> y};
//	POINT tail_position;
	if (head_direction == KEY_UP)
	{
		new_head_position.y -= 1;
	}
	else if (head_direction == KEY_DOWN)
	{
		new_head_position.y += 1;
	}
	else if (head_direction == KEY_LEFT)
	{
		new_head_position.x -= 1;
	}
	else if (head_direction == KEY_RIGHT)
	{
		new_head_position.x += 1;
	}
//	Uart_Printf("before enqueue\n");
//	enqueue(&queues[snake_object.queue_no], &new_head_position);
//	Uart_Printf("after enqueue\n");
//	int ret = dequeue(&queues[snake_object.queue_no], &tail_position, HAVE_PERMISSION);
//	Uart_Printf("ret: %d\n", ret);
//	Uart_Printf("after dequeue\n");

	Add_Snake_Position(&new_head_position);
	Remove_Snake_Position();
//	Lcd_Draw_New_Position(&new_head_position, &tail_position);
//	Uart_Printf("Calculate_Snake_Position End\n");
}

void Make_Target(void)
{
//	srand(time(NULL));  // 난수 초기화
	int rand_row, rand_column;
	rand_row = rand() % GAME_OBJECT_MAP_ROW;
	rand_column = rand() % GAME_OBJECT_MAP_COLUMN;
	Uart_Printf("rand_row: %d\n", rand_row);
	Uart_Printf("rand_column: %d\n", rand_column);
	Lcd_Draw_Box(rand_column * OBJECT_BLOCK_SIZE, rand_row * OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, OBJECT_BLOCK_SIZE, TARGET_COLOR);
}


void Lcd_Draw_IMG(int xs,  int ys,  int w,  int h,  unsigned short *img)
{
	unsigned int i;
	int xe, ye;
	xe = xs+w-1;
	ye = ys+h-1;
	if(xe >= 320) xe=319;
	if(ye >= 240) xe=239;

	Lcd_Set_Windows(xs,  ys,  xe,  ye);

	Lcd_CS_EN();
	Lcd_RS_REG();

	for(i=0; i < (xe - xs + 1) * (ye - ys + 1); i++)
	{
		_SPI1_Write_Byte(*img >> 8);
		_SPI1_Write_Byte(*img & 0xFF);
		img++;
	}

	Lcd_CS_DIS();
}


